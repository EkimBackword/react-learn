# Начало изучения

## Введение

Перед тем, как начинать изучать любой из ныне существующих фреймфорков, таких как *React*, *Vue.js*, *Angular 4+* и так далее, нужно изучить основы *JavaScript*.
Советую для начала изучить [Современный учебник Javascript](https://learn.javascript.ru/).
После чего закрепить свои знания и освоить *ES6*. Могу посоветовать  [*Youtube*-канал CodeDojo](https://www.youtube.com/channel/UCY10FZglXJ8RL3xB04VpykQ/featured), там вы сможете найти много качественного материала, в том числе по React. Особое внимание уделите основам ES6.
> *ES* — это сокращение для *ECMAScript* (языковая стандартизация). Если говорить простыми словами *JavaScript* - язык, *ECMAScript* - стандарт для него. Это нужно знать, потому что с каждым годом стандарт изменяется, но при этом не все браузеры успевают за ним. Если этого не знать, то можно сталкнуться с тем что ваш код не будет работать в некоторых браузера. Для кого-то это может быть не важным, но лучше заранее знать, чем попасть в нелепую ситуацию.

## Настройка окружения

В рамках изучения я буду использовать компьютер, на котором установлена операционная система *Windows 10*.
Прежде, чем начать програмировать нужно убедиться, что на вашем компьютере установлена все необходимое для разработки.

- *Node.js*
- Любой текстовый редактор (Например, я буду использовать [*VS Code*](https://code.visualstudio.com/))
- Также я бы посоветовал установить *git*. (Если вы не знаете что это, то советую вам поизучать такую тему, как **Система контроля версий**)

Так же при работе с *Node.js* я бы вам посоветовал [*Node Version Manager*](https://github.com/creationix/nvm).

**Заметка:** *nvm* не поддерживает *Windows*. Но при этом есть две альтернативы:

1. [*nvm-windows*](https://github.com/coreybutler/nvm-windows)
2. [*nodist*](https://github.com/marcelklehr/nodist)

## Первое приложение на *React*

Для разработки React приложения на локальном компьютере нужно иметь не только длобальное окружение разработки, но и локльная настройка.
Разработчики позаботились о пользователях и теперь не нужно настраивать локальные сервера и сборку приложения через *Webpack*, *Gulp* или чего-то подобного.

> Можно найти такую *CLI* которая поможет вам начать писать код через считаные минуты. Они есть и для *Vue.JS* и для *Angular*, но сейчас мы рассмотрим именно для *React*

[Create React apps with no build configuration.](https://github.com/facebook/create-react-app)

### **Команды для терминала**

```bash
    npm install -g create-react-app
    create-react-app my-app
    cd my-app
```

> Забегая в будующее, для *create-react-app* есть конфигурация по сборке под TypeScript - [react-scripts-ts](https://www.npmjs.com/package/react-scripts-ts)

## Основы *React*

React достаточно прост в изучении. Обычно приложения имеют сложную структуру и требуют вспомогательные библеотеки таких как: *React Router*, *Redax* и(или) других.

> Для детального изучения основ советую ознакомиться с приведёнными ссылками ниже:

- [ReactJS DOCS](https://reactjs.org/docs/hello-world.html)
- [Краткое руководство по React JS](https://habrahabr.ru/post/248799/)
- И другой литературы. В интернете вы можете нати массу книг и статей по *React*

## *Hello World*

Наверное каждый программист начинает изучать технологию с простейшего кода:

> Вывести на экран *Hello World*

### Пример кода

```JavaScript
    import React from 'react';
    import ReactDOM from 'react-dom';

    ReactDOM.render(
        <h1>Hello, world!</h1>,
        document.getElementById('root')
    );
```

## Введение в JSX

### **JSX** - это расширение синтаксиса *JavaScript*

> Например, объявим переменную HelloWorldElement таким образом:

```JavaScript
    const HelloWorldElement = <h1>Hello, world!</h1>;
```

Переменная *HelloWorldElement* не является ни строкой, ни HTML. Данный смешеный синтаксис говорит нам о том, что мы объявили *ReactElement*. То есть, *JSX* создает «элементы» *React*.

> **Элементы** - это  деталь (маленькая часть) приложений React.

При компиляции **Элементы** в *JSX* преобразуются в вызов функции `React.createElement()`:

#### **Данный код**

```JavaScript
    const element = (
        <h1 className="greeting">
            Hello, world!
        </h1>
    );
```

#### **Переобразуется в такой**

```JavaScript
    const element = React.createElement(
        'h1',
        {className: 'greeting'},
        'Hello, world!'
    );
```

### **JSX** - это выражение тоже

После компиляции выражения *JSX* становятся регулярными вызовами функций *JavaScript* и приравниваются к *JavaScript-объктам*. Это озночает, что *JSX* можно использовать в циклах *for* и условиях *if* и добавлять внутрь переменные.

```JavaScript
    function hi(userName) {
        if (userName) {
            return <h1>Hello, {userName}!</h1>;
        }
        return <h1>Hello, no name person.</h1>;
    }
```

> **Предупреждение**: Поскольку *JSX* ближе к *JavaScript*, чем к *HTML*, *React DOM* использует **camelCase** соглашение об именовании свойств вместо имен атрибутов *HTML*. Например, **class** становится **className** в *JSX* и **tabindex** становится **tabIndex**.

Теги *JSX* могут содержать дочерние элементы:

```JavaScript
    const element = (
        <div>
            <h1>Title</h1>
            <h2>Subtitle</h2>
        </div>
    );
```

### Предоставление элемента в *DOM*

Чтобы отрендерить (визуализировать) элемент *React* в *DOM*, нужно вызвать `ReactDOM.render()` с двумя аргументами (что отобразит и где отобразить):

```JavaScript
    const element = <h1>Hello, world</h1>;
    ReactDOM.render(element, document.getElementById('root'));
```

### Обновление элемента

*React* элементы **неизменяемы** (*immutable*). Создав элемент, вы не сможете изменить его дочерние элементы или атрибуты. Элемент можно сравнить с кадром в фильме: он представляет собой пользовательский интерфейс в определенный момент времени.

На данный момент мы знаем только один способ обновить интерфейс - это вызвать `ReactDOM.render()` с новым состоянием элемента.

```JavaScript
    function tick() {
        const MyTimer = (
            <h1> { new Date().toLocaleTimeString() }</h1>
        );
        ReactDOM.render(MyTimer, document.getElementById('root'));
    }

    setInterval(tick, 1000);
```

> **Заметка:** На практике большинство приложений React запускают `ReactDOM.render()` только один раз. Чуть позже мы разберёмся, как изменять состояние элементов.

## Компоненты и их свойства

> *Компоненты позволяют разделить пользовательский интерфейс на самостоятельные, многоразовые фрагменты и подумать о каждой части отдельно.*

### Функциональные компоненты и компоненты основанные на классах

Самый простой способ определить компонент - написать *JavaScript-функцию*:

```JavaScript
    function Hello(props) {
        return <h1>Hello, {props.name}</h1>;
    }
```

Эта функция является компонентой React, потому что она принимает на вход один аргумент *props* (который хранит в себе свойства) и возвращает *React-элемент*. Такие компоненты мы называем **«функциональными»**, потому что они буквально являются функциями *JavaScript*.

Вы также можете использовать классы ( из ES6 ) для определения компонентов:

```JavaScript
    class Hello extends React.Component {
        render() {
            return <h1>Hello, {this.props.name}</h1>;
        }
    }
```

> Классы имеют некоторые дополнительные функции (связанные с жизненым циклом компоненты), которые мы обсудим позже.

Когда React видит элемент, представляющий пользовательский компонент, он передает атрибуты *JSX* этому компоненту как единый объект (**props**).

```JavaScript
    function Hello(props) {
        return <h1>Hello, {props.name}</h1>;
    }

    ReactDOM.render( <Hello name="EkimBackword" />, document.getElementById('root') );
```

> **Предостережение:** Всегда начинайте имена компонентов с большой буквы. React обрабатывает компоненты, начинающиеся с строчных букв, как теги DOM.

Компоненты могут ссылаться на другие компоненты. Это позволяет использовать одну и ту же компоненту в разных местах. Например кастомная кнопка может быть элементом формы, частью списака меню или частью модального окна. Форма, модальное окно или даже таблица в приложениях React обычно выражаются как компоненты.

> Например, пост в инстаграмм: Это компонент, который содержит другие компоненты: UserInfo, Avatar, Comment и так далее.